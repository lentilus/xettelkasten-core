#!/bin/bash

set -e
source "$ZETTEL_WORKDIR/utils"

parse_args() {
    OPTSTRING=":z:p:"

    while getopts ${OPTSTRING} opt; do
        case ${opt} in
            z)
                zettel=$OPTARG
                ;;
            p)
                path=$OPTARG
                ;;
            :)
                echo "missing args"; exit
                ;;
            ?)
                echo "invalid option."; exit
                ;;
        esac
    done

    echo "zettel='$zettel'; path='$path'"
}

expand_main() (
        # populate subshell with vars
        export PREAMBLE="$PREAMBLE_FILE"
        envsubst < "$MAIN_TEMPLATE"
    )

expand_template() (
        # populate subshell with vars
        NAME="$(echo "$1" | tr '_' ' ')"
        export NAME
        export PREAMBLE="$PREAMBLE_FILE"
        envsubst < "$ZETTEL_TEMPLATE"
    )

copy_files() {
        log "copy preamble"

        cp  "$ZETTEL_PREAMBLE" "$ZETTEL_DATA/$PREAMBLE_FILE"
        expand_main > "$ZETTEL_DATA/glossary.tex" 
        for f in "$ZETTEL_WORKDIR"/../base/_*; do
            [ -f "$f" ] || continue
            name="$(basename "$f")"
            new_name="${name#_}"
            cp "$f" "$ZETTEL_DATA/$new_name"
        done
}

zettel_init() {
    if [ -d "$ZETTEL_DATA" ]; then
        info "reinitializing"
        copy_files
        exit
    fi
    info "initializing new zettelkasten"
    mkdir "$ZETTEL_DATA" || log "failed to init"
    copy_files
}


zettel_ls() {
    list="$(find "$ZETTEL_DATA" -mindepth 1 -maxdepth 1 -type d -not -path "$ZETTEL_DATA/.*")"
    for zettel in $list
    do
        printf %"s\n" "$(basename "$zettel")"
    done
}

zettel_rm() {
    eval "$(parse_args "$@")"
    rm -r "$ZETTEL_DATA/${zettel:?}" || log "error removing zettel"
}

zettel_path() {
    eval "$(parse_args "$@")"

    if [[ -n $zettel ]]; then
        [[ -d  "$ZETTEL_DATA/$zettel" ]] || exit 1
        echo "$ZETTEL_DATA/$zettel"
        exit
    elif [[ -n $path ]]; then 
        supplied="$(dirname "$(dirname "$path")")"

        # test validity of path
        [[ "$ZETTEL_DATA" -ef "$supplied" ]] || exit 1
        [[ -f $path ]] || exit 1
        
        basename "$(dirname "$path")"
        exit
    fi
    exit 1
}

zettel_insert() {
    eval "$(parse_args "$@")"
    
    zettel=${zettel// /_}

    if [ -d "$ZETTEL_DATA/$zettel" ]; then
        log "$zettel exists, aborting"
        exit
    fi

    mkdir "$ZETTEL_DATA/$zettel" || exit
    expand_template "$zettel" > "$ZETTEL_DATA/$zettel/$ZETTEL_FILENAME"
    touch "$ZETTEL_DATA/$zettel/$REFERENCE_FILENAME" || exit
    touch "$ZETTEL_DATA/$zettel/$TAG_FILENAME" || exit
    log "created $zettel"
    echo "$zettel"
}


case "$1" in
    init)
        shift
        zettel_init
        ;;
    ls)
        shift
        zettel_ls
        ;;
    rm)
        shift
        zettel_rm "$@"
        ;;
    mv)
        shift
        echo "not implemented"
        exit #TODO
        ;;
    path)
        shift
        zettel_path "$@"
        ;;
    insert)
        shift
        zettel_insert "$@"
        ;;
    *)
        echo "invalid top level command $1."
        ;;
esac
